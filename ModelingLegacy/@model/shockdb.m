function [runningData, YXEPG] = shockdb(this, runningData, range, varargin)
% shockdb  Create model-specific databank with random shocks
%
% __Syntax__
%
% Input arguments marked with a `~` sign may be omitted
%
%     outputDatabank = shockdb(model, inputDatabank, range, ...)
%
%
% __Input Arguments__
%
% * `model` [ model ] - Model object.
%
% * `inputDatabank` [ struct | empty ] - Input databank to which shock time
% series will be added; if omitted or empty, a new databank will be
% created; if `inputDatabank` already contains shock time series, the data
% generated by `shockdb` will be added up with the existing data.
%
% * `range` [ numeric ] - Date range on which the shock time series will be
% generated and returned; if `inputDatabank` already contains shock time
% series going before or after `range`, these will be clipped down to
% `range` in the output databank.
%
%
% __Output Arguments__
%
% * `outputDabank` [ struct ] - Databank with newly generated shock time
% series added.
%
%
% __Options__
%
% * `NumOfDraws=@auto` [ numeric | `@auto` ] - Number of draws (i.e.
% columns) generated for each shock; if `@auto`, the number of draws is
% equal to the number of alternative parameter variants in the model `M`,
% or to the number of columns in shock series existing in the input
% databank, `InputData`.
%
% * `ShockFunc=@zeros` [ `@lhsnorm` | `@randn` | `@zeros` ] - Function used
% to generate random draws for new shock time series; if `@zeros`, the new
% shocks will simply be filled with zeros; the random numbers will be
% adjusted by the respective covariance matrix implied by the current model
% parameterization.
%
%
% __Description__
%
% Create a databank of time series for all model shocks.  The time series
% are generated using a specified function, `ShockFunc`.  The two typical
% cases are `ShockFunc=@zeros`, generating a zero time series for each
% shock, and `ShockFunc=@randn`, generating random shocks from a Normal
% distribution and scaled appropriately by the model shock covariance
% matrix.
% 
% If the input databank, `inputDatabank`, already contains some time series
% for some of the model shocks, the newly generated values will be added to
% these. All other databank entries will be preserved in the output
% databank unchanged.
%
%
% __Example__
%

% -IRIS Macroeconomic Modeling Toolbox
% -Copyright (c) 2007-2019 IRIS Solutions Team

TYPE = @int8;
TIME_SERIES_CONSTRUCTOR = iris.get('DefaultTimeSeriesConstructor');
TIME_SERIES_TEMPLATE = TIME_SERIES_CONSTRUCTOR( );

persistent parser
if isempty(parser)
    parser = extend.InputParser('model.shockdb');
    parser.addRequired('Model', @(x) isa(x, 'model'));
    parser.addRequired('InputDatabank', @(x) isempty(x) || isstruct(x));
    parser.addRequired('Range', @(x) DateWrapper.validateProperRangeInput(x));
    parser.addOptional('NumOfDrawsOptional', @auto, @(x) isequal(x, @auto) || (isnumeric(x) && isscalar(x) && x==round(x) && x>=1));
    parser.addParameter('NumOfDraws', @auto, @(x) isnumeric(x) && isscalar(x) && x==round(x) && x>=1);
    parser.addParameter('ShockFunc', @zeros, @(x) isa(x, 'function_handle'));
end
parser.parse(this, runningData, range, varargin{:});
numOfDrawsOptional = parser.Results.NumOfDrawsOptional;
opt = parser.Options;
if ~isequal(numOfDrawsOptional, @auto)
    opt.NumOfDraws = numOfDrawsOptional;
end
range = double(range);

%--------------------------------------------------------------------------

numOfQuantities = numel(this.Quantity.Name);
inxOfE = getIndexByType(this, TYPE(31), TYPE(32));
ne = sum(inxOfE);
nv = length(this);
numOfPeriods = numel(range);
namesOfShocks = this.Quantity.Name(inxOfE);
labelOrName = this.Quantity.LabelOrName;
labelOrName = labelOrName(inxOfE);

if isempty(runningData) || isequal(runningData, struct( ))
    E = zeros(ne, numOfPeriods);
else
    requiredNames = cell.empty(1, 0);
    optionalNames = namesOfShocks;
    databankInfo = checkInputDatabank(this, runningData, range, requiredNames, optionalNames);
    E = requestData(this, databankInfo, runningData, range, namesOfShocks);
end
numOfPages = size(E, 3);

if isequal(opt.NumOfDraws, @auto)
    opt.NumOfDraws = max(nv, numOfPages);
end
checkNumOfDraws( );

numOfRuns = max([nv, numOfPages, opt.NumOfDraws]);
if numOfPages==1 && numOfRuns>1
    E = repmat(E, 1, 1, numOfRuns);
end

if isequal(opt.ShockFunc, @lhsnorm)
    S = lhsnorm(zeros(1, ne*numOfPeriods), eye(ne*numOfPeriods), numOfRuns);
else
    S = opt.ShockFunc(numOfRuns, ne*numOfPeriods);
end

for i = 1 : numOfRuns
    if i<=nv
        Omg = covfun.stdcorr2cov(this.Variant.StdCorr(:, :, i), ne);
        F = covfun.factorise(Omg);
    end
    E(:, :, i) = E(:, :, i) + F*reshape(S(i, :), ne, numOfPeriods);
end

if nargout==1
    for i = 1 : ne
        name = namesOfShocks{i};
        e = permute(E(i, :, :), [2, 3, 1]);
        runningData.(name) = replace(TIME_SERIES_TEMPLATE, e, range(1), labelOrName{i});
    end
elseif nargout==2
    [minShift, maxShift] = getActualMinMaxShifts(this);
    numOfExtendedPeriods = numOfPeriods-minShift+maxShift;
    baseColumns = (1:numOfPeriods) - minShift;
    YXEPG = nan(numOfQuantities, numOfExtendedPeriods, numOfRuns);
    YXEPG(inxOfE, baseColumns, :) = E;
end

return


    function checkNumOfDraws( )
        if nv>1 && opt.NumOfDraws>1 && nv~=opt.NumOfDraws
            THIS_ERROR = { 'Model:NumOfDrawIncompatibleWithParams'
                           [ 'Option NumOfDraws= is not consistent with the number ', ...
                             'of alternative parameter variants in the model object' ] };
            throw( exception.Base(THIS_ERROR, 'error') );
        end
        
        if numOfPages>1 && opt.NumOfDraws>1 && numOfPages~=opt.NumOfDraws
            THIS_ERROR = { 'Model:NumOfDrawIncompatibleWithPages'
                           [ 'Option NumOfDraws= is not consistent with the number ', ...
                             'of alternative data pags in the input databank' ] };
            throw( exception.Base(THIS_ERROR, 'error') );
        end
        
        if numOfPages>1 && nv>1 && nv~=numOfPages
            THIS_ERROR = { 'Model:PagesIncompatibleWithParams'
                           [ 'The number of alternative data pages in the input databank ', ...
                             'is not consistent with the number ', ...
                             'of alternative parameterizations in the model object' ] };
            throw( exception.Base(THIS_ERROR, 'error') );
        end
    end%
end%

